//
// Copyright (c) 2019 Fajar van Megen
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

library nem2_sdk_dart.sdk.model.message.encrypted_message;

import 'package:nem2_sdk_dart/core.dart' show CryptoUtils, HexUtils, SignSchema;

import '../blockchain/network_type.dart';

import 'message.dart';
import 'message_type.dart';
import 'plain_message.dart';

/// An encrypted message model defines a secure message that has been encrypted using
/// the NEM's SDK libraries.
///
/// Please note:
/// The strategy to encrypt and decrypt should be consistent between the different SDKs.
/// A client may send a transaction using a different encryption strategy than the recipient.
/// Even though the same encryption algorithm is used, the outcome may still be different
/// depending on the encoding process.
///
/// The encryption strategy this SDK uses is UTF-8 and hex encodings:
/// "plain text" string -> utf8 byte array -> encrypted byte array -> hex string
class EncryptedMessage extends Message {
  // private constructor
  EncryptedMessage._(String encryptedPayload)
      : super(MessageType.ENCRYPTED_MESSAGE, encryptedPayload);

  // Developer note:
  // If one to allow to create a EncryptedMessage object using this constructor, make sure to
  // put in place a check to see if the payload (in bytes) is actually encrypted or not.
  //  factory EncryptedMessage(final Uint8List encryptedPayload) {
  //    if (encryptedPayload == null) {
  //      throw new ArgumentError('The message payload must not be null');
  //    }
  //
  //    return new EncryptedMessage._(encryptedPayload);
  //  }

  /// Creates an encrypted message from [plainTextMessage] for the [networkType].
  ///
  /// The message is encrypted using a shared key generated by the [senderPrivateKey] and
  /// the [recipientPublicKey]. The recipient can decrypt this message using this shared key by
  /// taking the sender's public key and the recipient's public key.
  static EncryptedMessage create(final String plainTextMessage, final String senderPrivateKey,
      final String recipientPublicKey, final NetworkType networkType) {
    ArgumentError.checkNotNull(plainTextMessage);
    ArgumentError.checkNotNull(networkType);

    // Encrypts the message
    final SignSchema signSchema = NetworkType.resolveSignSchema(networkType);
    final String encryptedPayload = CryptoUtils.encryptMessage(
        plainTextMessage, senderPrivateKey, recipientPublicKey, signSchema);

    return EncryptedMessage._(encryptedPayload);
  }

  /// Creates an encrypted message from [payload].
  ///
  /// The [payload] is a hex encoded string.
  static EncryptedMessage fromPayload(final String payload) {
    if (!HexUtils.isHex(payload)) {
      throw new ArgumentError('message payload is not a valid hex string');
    }

    return new EncryptedMessage._(payload);
  }

  /// Decrypts an [encryptedMessage] sent for the [networkType].
  ///
  /// Returns a UTF-8 formatted string.
  static PlainMessage decrypt(
      final EncryptedMessage encryptedMessage,
      final String recipientPrivateKey,
      final String senderPublicKey,
      final NetworkType networkType) {
    ArgumentError.checkNotNull(encryptedMessage);
    ArgumentError.checkNotNull(encryptedMessage.payload);
    ArgumentError.checkNotNull(networkType);

    final SignSchema signSchema = NetworkType.resolveSignSchema(networkType);
    final String decrypted = CryptoUtils.decryptMessage(
        encryptedMessage.payload, recipientPrivateKey, senderPublicKey, signSchema);
    return PlainMessage.create(decrypted);
  }
}
