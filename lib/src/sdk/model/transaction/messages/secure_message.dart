//
// Copyright (c) 2019 Fajar van Megen
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

library nem2_sdk_dart.sdk.model.transaction.messages.secure_message;

import 'dart:typed_data' show Uint8List;

import 'package:encrypt/encrypt.dart';

import 'package:nem2_sdk_dart/core.dart' show CryptoException, Ed25519, HexUtils;

import 'message.dart';
import 'message_type.dart';

/// The secure message model defines a secure message with encrypted string.
class SecureMessage extends Message {
  static const int KEY_SIZE = 32;
  static const int BLOCK_SIZE = 16;

  // private constructor
  SecureMessage._(Uint8List encryptedPayload) : super(MessageType.ENCRYPTED, encryptedPayload);

// Developer note:
// If one to allow to create a SecureMessage object using this constructor, make sure to
// put in place a check to see if the payload (in bytes) is actually encrypted or not.
//  factory SecureMessage(final Uint8List encryptedPayload) {
//    if (encryptedPayload == null) {
//      throw new ArgumentError('The message payload must not be null');
//    }
//
//    return new SecureMessage._(encryptedPayload);
//  }

  /// Creates a secure message with an encrypted payload.
  ///
  /// The [message] encrypted using a shared key generated by the [senderPrivateKey] and
  /// the [receiverPublicKey]. The receiver can decrypt the message using this shared key.
  static SecureMessage create(
      final String message, final Uint8List senderPrivateKey, final Uint8List receiverPublicKey) {
    if (message == null) {
      throw new ArgumentError('message cannot be null');
    }

    if (senderPrivateKey == null ||
        senderPrivateKey.isEmpty ||
        receiverPublicKey == null ||
        receiverPublicKey.isEmpty) {
      throw new ArgumentError(
          'Sender private key and receiver public key are required to create an encrypted message payload');
    }

    Uint8List payload;
    if (HexUtils.isHex(message)) {
      // Hex string message payload
      payload = HexUtils.getBytes(HexUtils.tryHexToUtf8(message));
    } else {
      // Plain text (UTF-8) message payload
      payload = HexUtils.getBytes(HexUtils.utf8ToHex(message));
    }

    // Encrypts the message
    final Uint8List salt = Ed25519.getRandomBytes(KEY_SIZE);
    final iv = IV(Ed25519.getRandomBytes(BLOCK_SIZE));
    final Uint8List sharedKey = Ed25519.deriveSharedKey(salt, senderPrivateKey, receiverPublicKey);
    final Encrypter encrypter = Encrypter(AES(Key(sharedKey), mode: AESMode.cbc));
    final encryptedMessage = encrypter.algo.encrypt(payload, iv: iv);

    // Creates a concatenated byte array as the encrypted payload
    final Uint8List encryptedPayload = Uint8List.fromList(salt + iv.bytes + encryptedMessage.bytes);
    return SecureMessage._(encryptedPayload);
  }

  /// Decodes the encrypted message payload.
  String decryptMessage(final Uint8List senderPrivateKey, final Uint8List receiverPublicKey) {
    if (payload == null) {
      throw new ArgumentError('there is no paylaod to decode');
    }

    const int totalLength = KEY_SIZE + BLOCK_SIZE;
    if (payload.length < (totalLength)) {
      throw new ArgumentError('the encrypted payload has an incorrect size');
    }

    final Uint8List salt = _extractSalt();
    final Uint8List iv = _extractIV();
    final Uint8List encrypted = _extractEncryptedMessage();

    try {
      final Uint8List sharedKey =
          Ed25519.deriveSharedKey(salt, senderPrivateKey, receiverPublicKey);
      final Encrypter encrypter = Encrypter(AES(Key(sharedKey), mode: AESMode.cbc));
      final String decrypted = encrypter.decrypt(Encrypted(encrypted), iv: IV(iv));
      return decrypted;
    } catch (e) {
      throw new CryptoException('Failed to decrypt message');
    }
  }

  // ------------------------------ private / protected functions ------------------------------ //

  Uint8List _extractSalt() {
    return Uint8List.fromList(payload.take(KEY_SIZE).toList());
  }

  Uint8List _extractIV() {
    return Uint8List.fromList(payload.skip(KEY_SIZE).take(BLOCK_SIZE).toList());
  }

  Uint8List _extractEncryptedMessage() {
    return Uint8List.fromList(payload
        .skip(KEY_SIZE + BLOCK_SIZE)
        .take(payload.length - (KEY_SIZE + BLOCK_SIZE))
        .toList());
  }
}
